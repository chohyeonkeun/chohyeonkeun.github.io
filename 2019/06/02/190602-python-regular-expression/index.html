<!DOCTYPE html>
<html lang="ko">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="naver-site-verification" content="c017b080593f962c8c0a7ca644404511803c6484">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="신입개발자 조누스로써의 역량을 키워가는 과정이 담겨있는 개발로그입니다.">
  <meta property="og:title" content="조누스의 걸음마 개발로그">
  <meta property="og:description" content="안녕하세요 열정괴물 신입개발자 조누스의 개발로그입니다.">
  <meta property="og:url" content="https://chohyeonkeun.github.io">
  <title>파이썬 - 정규표현식 기초 학습 | 조누스의 걸음마 개발 로그</title>
  
  
  
  <link rel="canonical" href="https://jonus.github.io/2019/06/02/190602-python-regular-expression/">
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class="SideBar">
    <section class="avatar" style="background-image: url()">
        <div class="av-pic" style="background-image: url(/assets/me.jpg)">
        </div>
    </section>
    <section class="menu">
	<div>웹 프로그래머</div>
        <div style="font-weight: bold">조누스의 걸음마 개발 로그</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/chohyeonkeun">
                    <img src="/assets/github.svg">
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class="ContentView">
    <header class="PageTitle">
        <h1>파이썬 - 정규표현식 기초 학습</h1>
    </header>

    <section>
      <h2 id="정규표현식이란"><a href="#정규표현식이란" class="headerlink" title="정규표현식이란?"></a>정규표현식이란?</h2><hr>
<ul>
<li>특정한 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어</li>
<li>프로그래밍 언어 혹은 텍스트 에디터 등에서 문자열의 검색과 치환을 위한 용도로 사용</li>
<li>정규표현식에서 사용하는 기호를 메타 문자라고 한다.</li>
<li>메타 문자(meta characters) : 원래 그 문자가 가진 뜻이 아닌 표현식 내부에서 특정한 의미를 갖는 문자<ul>
<li>ex) . 6 $ * + ? { } [ ] \ | ( )</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="문자-클래스"><a href="#문자-클래스" class="headerlink" title="문자 클래스 [ ]"></a>문자 클래스 [ ]</h2><hr>
<ul>
<li>문자 클래스로 만들어진 정규식은 “ [  ] 사이의 문자들과 매치 “ 라는 의미를 갖는다.</li>
<li>예를 들어 [abc]는 “a, b, c 중 한개의 문자와 매치” 를 의미한다.<ul>
<li>“apple” –&gt; 정규식과 일치하는 문자 “a”가 있으므로 매치</li>
<li>“bottle” –&gt; 정규식과 일치하는 문자 “b”가 있으므로 매치</li>
<li>“dog” –&gt; 정규식과 일치하는 문자 없으므로 매치되지 않음</li>
</ul>
</li>
<li>[  ] 안의 두 문자 사이에 하이픈(-)을 사용하면, 두 문자 사이의 범위(from-to) 를 의미한다.<ul>
<li>정규표현식 [a-c]은 [abc]와 동일하고, [0-5]는 [012345]와 동일</li>
<li>[a-zA-Z] : 알파벳(소문자/대문자) 모두</li>
<li>[0-9] : 숫자</li>
</ul>
</li>
<li>[  ] 안에 ^ 메타 문자는, 반대(not)라는 의미를 갖는다.<ul>
<li>^[0-9] : 숫자가 아닌 문자만 매치</li>
</ul>
</li>
<li>자주 사용하는 문자 클래스<ul>
<li>^ : 문자열 시작</li>
<li>$ : 문자열 종료</li>
<li>\d : 숫자와 매치</li>
<li>\D : 숫자가 아닌 것과 매치, [^0-9]와 동일</li>
<li>\s : whitespace 문자와 매치, [ \t\n\r\f\v]와 동일(맨 앞 빈 칸은 공백문자를 의미)</li>
<li>\S : whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일</li>
<li>\w : 문자+숫자와 매치, [a-zA-Z0-9_]와 동일</li>
<li>\W : 문자+숫자가 아닌 것과 매치, [^a-zA-Z0-9_]와 동일</li>
</ul>
</li>
</ul>
<h2 id="Dot"><a href="#Dot" class="headerlink" title="Dot(.)"></a>Dot(.)</h2><hr>
<ul>
<li>정규표현식의 Dot(.) 메타 문자는 줄바꿈 문자인 \n를 제외한 모든 문자와 매치(옵션으로 re.DOTALL 옵션을 주면, \n 문자와도 매치)</li>
<li>a.b 는 “a + 모든문자 + b”라는 의미<ul>
<li>ex) “aab”, “a0b”, “aAb” –&gt; “a”와 “b”사이에 모든 문자를 의미하는 . 과 일치하므로 매치</li>
<li>ex) “abc” –&gt; “a”와 “b” 사이에 어떤 문자도 없으므로 매치되지 않음</li>
</ul>
</li>
<li>주의 : a[.]b 는 “a + Dot(.)문자 + b”라는 의미 <ul>
<li>“a.b” 문자열만 매치</li>
</ul>
</li>
</ul>
<h2 id="반복"><a href="#반복" class="headerlink" title="반복(*)"></a>반복(*)</h2><hr>
<ul>
<li><em>의 의미는 </em> 바로 앞에 있는 문자가 최소 0번 이상 무한대로 반복될 수 있다는 것<ul>
<li>ex) ca*t –&gt; “ct”, “cat”, “caaaat” 매치</li>
</ul>
</li>
</ul>
<h2 id="반복-1"><a href="#반복-1" class="headerlink" title="반복(+)"></a>반복(+)</h2><hr>
<ul>
<li>+의 의미는 + 바로 앞에 있는 문자가 최소 1번 이상 무한대로 반복될 수 있다는 것<ul>
<li>ex) ca+t –&gt; “cat”, “caaaat” 매치</li>
</ul>
</li>
</ul>
<h2 id="반복-m-n"><a href="#반복-m-n" class="headerlink" title="반복({m,n},?)"></a>반복({m,n},?)</h2><hr>
<ul>
<li>{m,n}의 의미는 반복 횟수가 m부터 n까지인 것을 매치한다는 의미<ul>
<li>m 또는 n 생략 가능<ul>
<li>{3,} –&gt; 반복 횟수 3번 이상인 경우</li>
<li>{,3} –&gt; 반복 횟수 3번 이하인 경우</li>
<li>{3} –&gt; 반복 횟수 3번인 경우</li>
</ul>
</li>
<li>{1,} 는 * 메타 문자와 동일</li>
<li>{0,} 는 + 메타 문자와 동일</li>
<li>{0, 1} 는 ? 메타 문자와 동일<ul>
<li>ab?c –&gt; “a + b(있어도 되고 없어도 된다) + c”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="파이썬에서-정규-표현식을-지원하는-re-모듈"><a href="#파이썬에서-정규-표현식을-지원하는-re-모듈" class="headerlink" title="파이썬에서 정규 표현식을 지원하는 re 모듈"></a>파이썬에서 정규 표현식을 지원하는 re 모듈</h2><hr>
<ul>
<li>파이썬은 정규 표현식을 지원하기 위해 re(regular expression의 약어) 모듈 제공</li>
<li>re 모듈은 파이썬 설치될 때 자동 설치되는 기본 라이브러리<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.compile(<span class="string">'ab*'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="정규식-이용한-문자열-검색"><a href="#정규식-이용한-문자열-검색" class="headerlink" title="정규식 이용한 문자열 검색"></a>정규식 이용한 문자열 검색</h2><hr>
<ul>
<li>컴파일 된 패턴 객체는 4가지 메소드 제공<ul>
<li>match() : 문자열 처음부터 정규식과 매치되는지 조사</li>
<li>search() : 문자열 전체 검색하여 정규식과 매치되는지 조사</li>
<li>findall() : 정규식과 매치되는 모든 문자열을 리스트로 리턴</li>
<li>finditer() : 정규식과 매치되는 모든 문자열을 iterator 객체로 리턴</li>
</ul>
</li>
<li>match, search는 정규식과 매치 될 경우, match객체 리턴(매치되지 않을 경우 None 리턴)</li>
<li><p>match</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.compile(<span class="string">'[a-z]+'</span>)</span><br><span class="line"></span><br><span class="line">m = p.match(<span class="string">"python"</span>)</span><br><span class="line">print(m) <span class="comment"># &lt;_sre.SRE_Match object at 0x01F3F9F8&gt;</span></span><br><span class="line"></span><br><span class="line">m = p.match(<span class="string">"3 python"</span>)</span><br><span class="line">print(m) <span class="comment"># None</span></span><br><span class="line"><span class="comment"># "3 python" 문자열의 처음 문자인 3이 정규식 [a-z]+ 에 부합되지 않으므로 None 리턴</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이썬 정규식 프로그램은 보통 아래와 같은 흐름으로 작성</span></span><br><span class="line">m = p.match(<span class="string">'string goes here'</span>)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">    print(<span class="string">'Match found: '</span>, m.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'No match'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>search</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = p.search(<span class="string">"python"</span>)</span><br><span class="line">print(m) <span class="comment"># &lt;_sre.SRE.Match object at 0x01F3FA68</span></span><br><span class="line"></span><br><span class="line">m = p.search(<span class="string">"3 python"</span>)</span><br><span class="line">print(m) <span class="comment"># &lt;_sre.SRE.Match object at 0x01F3FA30&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>findall</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = p.findall(<span class="string">"life is too short"</span>)</span><br><span class="line">print(result) <span class="comment"># ['life', 'is', 'too', 'short']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>finditer</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = p.finditer(<span class="string">"life is too short"</span>)</span><br><span class="line">print(result) <span class="comment"># &lt;callable_iterator object at 0x01F5E390&gt;</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result: </span><br><span class="line">    print(r)</span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object at 0x01F3F9F8&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object at 0x01F3FAD8&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object at 0x01F3FAA0&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object at 0x01F3F9F8&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>finditer는 findall과 동일하지만, 반복 가능한 객체(iterator object)를 리턴한다. (match 객체)</li>
</ul>
</li>
</ul>
<h2 id="match-객체의-메서드"><a href="#match-객체의-메서드" class="headerlink" title="match 객체의 메서드"></a>match 객체의 메서드</h2><hr>
<ul>
<li><p>match 객체의 메서드</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = p.match(<span class="string">"python"</span>)</span><br><span class="line">m.group()  <span class="comment"># 'python'</span></span><br><span class="line">m.start()  <span class="comment"># 0</span></span><br><span class="line">m.end()  <span class="comment"># 6</span></span><br><span class="line">m.span()  <span class="comment"># (0, 6)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>group() : 매치된 문자열 리턴</li>
<li>start() : 매치된 문자열의 시작 위치 리턴</li>
<li>end() : 매치된 문자열의 끝 위치 리턴</li>
<li>span() : 매치된 문자열의 (시작, 끝)에 해당하는 튜플 리턴</li>
</ul>
</li>
<li><p>re.compile 축약 방법</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'[a-z]+'</span>)</span><br><span class="line">m = p.match(<span class="string">"python"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 컴파일과 match 메서드 한번에 수행</span></span><br><span class="line">m = re.match(<span class="string">'[a-z]+'</span>, <span class="string">"python"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="컴파일-옵션"><a href="#컴파일-옵션" class="headerlink" title="컴파일 옵션"></a>컴파일 옵션</h2><ul>
<li>정규식을 컴파일할 때 아래와 같은 옵션 사용<ul>
<li>DOTALL(S) : 메타문자 . 이 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.</li>
<li>IGNORECASE(I) : 대소문자 상관없이 매치</li>
<li>MULTILINE(M) : 여러줄과 매치(^, $ 메타 문자 사용과 관계있는 옵션)</li>
<li>VERBOSE(X) : verbose 모드 사용(정규식을 보기 편하게 만들고, 주석 등 사용 가능)</li>
</ul>
</li>
<li><p>DOTALL,S (re.DOTALL 혹은 re.S)</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.compile(<span class="string">'a.b'</span>)</span><br><span class="line">m = p.match(<span class="string">'a\nb'</span>)</span><br><span class="line">print(m)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">p = re.compile(<span class="string">'a.b'</span>, re.DOTALL)</span><br><span class="line">m = p.match(<span class="string">'a\nb'</span>)</span><br><span class="line">print(m)  <span class="comment"># &lt;_sre.SRE_Match object at 0x01FCF3D8&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>IGNORECASE,I (re.IGNORECASE 혹은 re.I)</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'[a-z]'</span>, re.I)</span><br><span class="line">p.match(<span class="string">'python'</span>)  <span class="comment"># &lt;_sre.SRE_Match object at 0x01FCFA30&gt;</span></span><br><span class="line">p.match(<span class="string">'Python'</span>)  <span class="comment"># &lt;_sre.SRE_Match object at 0x01FCFA68&gt;</span></span><br><span class="line">p.match(<span class="string">'PYTHON'</span>)  <span class="comment"># &lt;_sre.SRE_Match object at 0x01FCF9F8&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MULTILINE,M (re.MULTILINE 혹은 re.M)</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.compile(<span class="string">"^python\s\w+"</span>)</span><br><span class="line"><span class="comment"># ^ 메타 문자에 의해 python 문자열이 사용된 첫 번째 라인만 매치</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">"""python one</span></span><br><span class="line"><span class="string">life is too short</span></span><br><span class="line"><span class="string">python two</span></span><br><span class="line"><span class="string">you need python</span></span><br><span class="line"><span class="string">python three"""</span></span><br><span class="line"></span><br><span class="line">print(p.findall(data)) <span class="comment"># ['python one']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^ 메타 문자를 문자열 전체가 아닌 각 라인의 처음으로 인식시키고 싶은 경우</span></span><br><span class="line">p = re.compile(<span class="string">"^python\s\w+"</span>, re.MULTILINE)</span><br><span class="line"></span><br><span class="line">print(d.findall(data))  <span class="comment"># ['python one', 'python two', 'python three']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>VERBOSE,X (re.VERBOSE 또는 re.X)</p>
<ul>
<li>이해하기 어려운 정규식을 주석 또는 라인 단위로 구분하여 가독성있게 작성하고 싶을 때 사용<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">charref = re.compile(<span class="string">r'&amp;[#](0[0-7]+|[0-9]+|x[0-9a-fA-F]+);'</span>)</span><br><span class="line"></span><br><span class="line">charref = re.compile(<span class="string">r"""</span></span><br><span class="line"><span class="string">&amp;[#]                # Start of a numeric entity reference)</span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">    0[0-7]+         # Octal form</span></span><br><span class="line"><span class="string">    |[0-9]+         # Decimal form</span></span><br><span class="line"><span class="string">    |x[0-9a-fA-F]+  # Hexadecimal form</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">;                   # Trailing semicolon</span></span><br><span class="line"><span class="string">"""</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="백슬래쉬-문제"><a href="#백슬래쉬-문제" class="headerlink" title="백슬래쉬 문제"></a>백슬래쉬 문제</h2><hr>
<ul>
<li><p>“\section”이라는 문자열을 찾기 위한 정규식을 만들고 싶은 경우</p>
<ul>
<li><p>\section에서 \s 문자가 whitespace로 해석되므로, <code>\\section</code> 으로 변경하여 사용하여 이스케이프 처리를 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'\\section'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>하지만, 실제 파이썬 정규식 엔진에는 파이썬 문자열 리터럴 규칙에 의하여 <code>\\</code>이 <code>\</code>로 변경되어 <code>\section</code>이 전달된다.</p>
</li>
<li><p>따라서, 파이썬은 <code>\\\\</code> 백슬래쉬 4개를 사용해야 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'\\\\section'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>상기와 같은 문제를 해결하기 위해 파이썬 정규식에는 Raw string이 생겨났다.</p>
</li>
<li><p>즉, 컴파일해야 하는 정규식이 Raw String임을 알려줄 수 있도록 파이썬 문법이 만들어진 것</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">r'\\section'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>정규식 문자열 앞에 r 문자를 선행하면 이 정규식은 Raw String 규칙에 의해 백슬래시 2개 대신 1개만 써도 두개를 쓴 것과 동일한 의미를 가진다.</p>
</li>
</ul>
</li>
</ul>


      

    </section>
    
      <section class="ArticleMeta">
          <div>
            Posted &nbsp;
            <time datetime="2019-06-02T08:00:21.000Z" itemprop="datePublished">
              2019-06-02
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Python/">Python</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/regular-expression/">regular-expression</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2021 - 조현근 </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>
